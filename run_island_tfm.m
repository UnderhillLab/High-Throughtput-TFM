
 
function [all_cell_data]  = run_island_tfm(varagin)
% This function runs the TFM analysis. No inputs are required. 
% Output: all_cell_data (also saved in the folder "data_out" with file name
% set by either the user or generated by the program using the conditions
% all_cell_data is a cell array with each cell corresponding to a single
% "island"
% all_cell_data{i} is a structure with fields
%              cell_info: [1×1 struct]
%                 Images: {1×3 cell}
%        cell_boundaries: [1×1 struct]
%     cell_displacements: [1×1 struct]
%         cell_tractions: [1×1 struct]
% see protocol documentation for full explanation of all outputs


% This program was compliled at the University of Illinois, by Ian Berg in
% 2019. This program is free software: you can redistribute it and/or modify
% it under the terms of the GNU General Public License as
% published by the Free Software Foundation, either version 2 of the
% License, or (at your option) any later version.
%
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
%
% You should have received a copy of the GNU General Public License along
% with this program; if not, write to the Free Software Foundation, Inc.,
% 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

main = cd;
addpath('bfmatlab')
addpath('qDIC-master')
addpath('L FTTC')
addpath('utilities')

if nargin  == 0
%% Read in images and set parameters 

fprintf('Select brightfield or phase image\n')
%%% Slect the images to be analyzed with a pop up expolorer
[bf_cell_prefix,path] = uigetfile('*.*','Select the bright field image');
cd(path);
fprintf('Select the pre-dissociation image\n')
[fluor_bef_prefix,~] = uigetfile('*.*','Select the pre-dissociation image');
fprintf('Select the post-dissociation image\n')
[fluor_aft_prefix,~] = uigetfile('*.*','Select the post-dissociation image');
bf_cell_file= [path, bf_cell_prefix];
fluor_bef_file= [path, fluor_bef_prefix];
fluor_aft_file= [path, fluor_aft_prefix];

cd(main)

%load image meta data 
reader_bf = bfGetReader(bf_cell_file);
reader_bef = bfGetReader(fluor_bef_file);
reader_aft = bfGetReader(fluor_aft_file);
omeMeta = reader_bf.getMetadataStore();
SeriesCount = reader_bf.getSeriesCount();
pixelsize = double(omeMeta.getPixelsPhysicalSizeX(0).value()); % in micron

%load and display island locations used to select islands and match
%conditions
for i = 1:SeriesCount
    XYposition(i,1) = double(omeMeta.getPlanePositionX(i-1,0).value());
    XYposition(i,2) = double(omeMeta.getPlanePositionY(i-1,0).value());
    str{i} = num2str(i);
end

% A GUI is used to enter experiment information, select islands, and map isl 
% Fields are used to assemble a file name for the output

%presents experiment information. ALl fields can be changed in GUI
experiment = ' ';
date_ID = ' ';
soluble = ' ';
dish_num = ' ';
time = ' ';
young = ' ';
pois = '0.48';
num_array = ' ';

fprintf('Enter Experiment Information\n')

[experiment,...
date_ID,...
soluble,...
dish_num,...
time,...
young,...
pois,...
num_array,...
pixelsize,...
save_file_name,...
arrayed_conditions,...
arrayed_condition_islands] = ...
Enter_Info_GUI(experiment,...
        date_ID,...
        soluble,...
        dish_num,...
        time,...
        young,...
        pois,...
        num_array,...
        pixelsize,...
        bf_cell_prefix,...
        XYposition,...
        str);

young = str2num(young);
pois = str2num(pois);
pixelsize = str2num(pixelsize);

%%
file_ind = 0;
for cur_cond_ind = 1:length(arrayed_conditions) %index through arrayed conditions
    
    cur_arrayed_cond = arrayed_conditions{cur_cond_ind};
    cur_cond_islands = arrayed_condition_islands{cur_cond_ind};
    
    for island_cond_ind = 1:length(cur_cond_islands) %index through islands mapped to condition

        count_i = cur_cond_islands(island_cond_ind);
        file_ind = file_ind + 1;

        close all

        reader_bf.setSeries(count_i-1);
        reader_bef.setSeries(count_i-1);
        reader_aft.setSeries(count_i-1);

        cell_info.young = young;
        cell_info.pois = pois;
        cell_info.pixelsize = pixelsize;
        cell_info.experiment = experiment;
        cell_info.date_ID = date_ID;
        cell_info.soluble = soluble;
        cell_info.dish_num = dish_num;
        cell_info.time = time;
        cell_info.arrayed_condition = cur_arrayed_cond;
        cell_info.Xposition = XYposition(count_i,1);
        cell_info.Yposition = XYposition(count_i,2);
        cell_info.image_number = count_i;
        cell_info.file = bf_cell_file;
        
        fprintf(['Loading Images for Island ' num2str(count_i),' \n']);
        bf_cell = bfGetPlane(reader_bf, 1); 
        fluor_nocell = bfGetPlane(reader_aft, 1);
        fluor_cell = bfGetPlane(reader_bef, 1);
        fprintf('Images Loaded\n');

%% Correct Frame Shift between the pre and post dissociation images
        fprintf('correcting frame shift\n')
        [im_cell, im_nocell, im_bf, shift] = frame_shift(fluor_cell, fluor_nocell, bf_cell,'y');%change to 'n' for manual selection of regions 
        fprintf('frame shift correction complete! \n')
        Images{1} = mat2gray(im_cell);
        Images{2} = mat2gray(im_nocell);
        Images{3} = mat2gray(im_bf); 
        clear('fluor_cell', 'fluor_nocell', 'bf_cell','im_cell','im_nocell','im_bf'); 


%% Draw Boundary Around Cell

        %preset settings for boundary drawing if not set from previous cycle
        fprintf('Draw boundary around cell (assisted or or manually)\n')
        if ~exist('sigma','var')
        sigma = 2*floor(max(size(Images{3}))/16);
        [~,cny] = edge(Images{3},'canny');
        di = 8; 
        end

        [boundary_points,mask] = cell_boundary(Images{3}, sigma, cny, di); %run boundary drawing once
        % run GUI for uses assisted boundary drawing
        [sigma, cny, di,mask,boundary_points] = island_boundary_GUI(Images{3},sigma,cny(2),di,boundary_points,mask);

        cell_boundaries.mask = mask;
        cell_boundaries.boundary_points = boundary_points;
        cell_boundaries.cny = cny;
        cell_boundaries.sigma = sigma;
        cell_boundaries.di = di;

%% Save data
        
        cell_data.cell_info = cell_info;
        cell_data.Images = Images;
        cell_data.cell_boundaries = cell_boundaries;
        all_cell_data{file_ind} = cell_data;
        
    end
end

fprintf('Saving Data\n')
save(['data out\' save_file_name] ,'all_cell_data','-v7.3')

else
   
    [save_file_name,path] = uigetfile;
    all_cell_data = load([path, save_file_name]);
    all_cell_data = all_cell_data.all_cell_data;
    file_ind = length(all_cell_data);
end    

for ind = 1:file_ind %index throuhg all islands loaded and mapped
%% initialize paramters of island
    cell_data = all_cell_data{ind};
    cell_info = cell_data.cell_info;
    Images = cell_data.Images;
    pixelsize = cell_info.pixelsize;
    young = cell_info.young;
    pois = cell_info.pois;
    cell_boundaries = cell_data.cell_boundaries;
    mask = cell_boundaries.mask;
    boundary_points = cell_boundaries.boundary_points;

    %consolidate mutliple ROIs into a single mask for calculation
    mask(mask>0) = 1;
    boundary_points_temp = [];
    for i = 1:length(boundary_points)
        boundary_points_temp = [boundary_points_temp;boundary_points{i}];
    end
    boundary_points = {};
    boundary_points{1} = boundary_points_temp;
    boundary = boundary_points{1};
        
    %% Estimate displacements using DIC


    sSize = 2^min(floor(log2(size(Images{2}))))/2; %starting interogation window size for IDIC
    sSize = sSize.*ones(1,2);
    sSizemin = 32;

    if max(abs(size(Images{1})-size(Images{2})))==0

    u0 = num2cell(zeros(1,2)); %initial displacement guess, set to 0

    % Runs displacement calculation from:
    % Landauer, A.K., Patel, M., Henann, D.L. et al. Exp Mech (2018). 
    % https://doi.org/10.1007/s11340-018-0377-4
    % Original code available at https://github.com/FranckLab/qDIC
    
        if nargin == 0
        
        formatSpec = 'Begin Island %2.0f Displacement Measurement (%2.0f of %2.0f ) \n';
        fprintf(formatSpec,cell_info.image_number,ind,file_ind)
        [u, ~, dm, m_final,~] = IDIC(Images, sSize, sSizemin, u0);

        else

        % loads displacements from file instead of rerunning
        cell_displacements = cell_data.cell_displacements;
        u = cell_displacements.raw_displacements;
        dm = cell_data.cell_info.dm;
        end
    
    else
        u{1} = zeros(floor(size(Images{2})/dm));
        u{2} = zeros(floor(size(Images{2})/dm));
        u{3} = zeros(floor(size(Images{2})/dm));
        fprintf('error with image sizes \n');  
    end

    cell_displacements.raw_displacements = u;
    cell_info.dm = dm; 
    cell_data.cell_info = cell_info;
    cell_data.cell_displacements = cell_displacements;
    
    formatSpec = 'Completed Island %2.0f of %2.0f Displacement Measurement\n';
    fprintf(formatSpec,ind,file_ind)
    close all;
    
    if nargin == 0
    all_cell_data{ind} = cell_data;
    save(['data out\' save_file_name],'all_cell_data','-v7.3')
    end

    
%% Calculate traction forces from displacement field with the FTTC Method
    formatSpec = 'Island %2.0f of %2.0f Traction Calculation\n';
    fprintf(formatSpec,ind,file_ind)

    clear('U');
    for i = 1:length(u)
        dim = floor(min(size(u{i}))/2)*2;
        u{i} = u{i}(1:dim,1:dim);
        u{i}(isnan(u{i})) = 0;
        U(:,:,i) = u{i};
    end
    U(isnan(U)) = 0;
        
    clear('reg_grid');
                
    [x,y] = meshgrid(dm:dm:size(u{1},1)*dm,dm:dm:size(u{1},2)*dm);
    reg_grid(:,:,1) = x';
    reg_grid(:,:,2) = y';
    
    i_max = size(u{1},1);
    j_max = size(u{2},2);

    ux=wiener2(u{1},[12,12]);   %wiener filter to smooth out noise
    uy=wiener2(u{2},[12,12]);   
    
    U(:,:,1) = ux;
    U(:,:,2) = uy;

    % Runs FFTC traction force calculation from:
    % Biophys J. 2008 Jan 1; 94(1): 207–220.
    % doi: 10.1529/biophysj.107.113670
    %
    % and
    %
    % Han et al., Nature Methods (2015)
    % https://www.nature.com/articles/nmeth.3430
    %
    % Original Code available from the Danuser Lab, available at
    % https://github.com/DanuserLab/TFM

    reg_corner = 1e-5;
    % The appropriate regularization paramter (reg_corner)  will differ 
    % based on the the noise in the data,  
    % it can be set above and applied to all islands. Alternatitively, it 
    % can be determined using a set of objective criteria using the calculateLcurveFTTC and regParamSelecetionLcurve
    % (from Han et al., Nature Methods (2015)) which is provided in the
    % package. It may add significant time to the total compuation time
    
%     L = .01;
%     Lcurvefactor = 10;
%     [rho,eta,reg_corner,alphas] = calculateLcurveFTTC(reg_grid, U, young, pois, dm, i_max, j_max, L , Lcurvefactor);
%     [reg_corner,ireg_corner,kappa,h]=regParamSelecetionLcurve(alphas',eta,alphas,reg_corner,'manualSelection',true);
    
    [pos,vec,force, fnorm,energie,f] = reg_fourier_TFM(reg_grid, U, young, pois, pixelsize, dm, i_max, j_max, reg_corner);
    
    t{1} = (f(:,:,1));
    t{2} = (f(:,:,2));
    t{3} = (t{1}.^2 + t{2}.^2).^0.5;
%     figure;imagesc(t{3}); colorbar;

    uu{1} = U(:,:,1).*pixelsize;
    uu{2} = U(:,:,2).*pixelsize;
    uu{3} = (uu{1}.^2 + uu{2}.^2).^0.5;
    
    N = 2*size(u{1},1);
    mask_scale = imresize(mask,[N/2, N/2]);
    mask_scale = im2bw(mask_scale, 0.25);

    tx_int = t{1}.*mask_scale;
    ty_int = t{2}.*mask_scale;
    ux_int = u{1}.*mask_scale;
    uy_int = u{1}.*mask_scale;

    RMS = sqrt(mean2(t{1}.^2 + t{2}.^2));
    RMS_int = sqrt(mean2(t{1}(mask_scale).^2 + t{2}(mask_scale).^2));
    
    cell_displacements.displacements = uu;
    cell_tractions.tractions = t;
    cell_tractions.RMS = RMS;
    cell_tractions.RMS_int = RMS_int;
    cell_tractions.Strain_Energy = energie;
    cell_tractions.reg_corner = reg_corner;
        
    %% Fit an eplipse to the cell boundary

    boundary_points = cell_data.cell_boundaries.boundary_points;
    
    area_b_i = [];
    for bi = 1:length(boundary_points)
        bound_i = boundary_points{bi};
        area_b_i(bi,1) = polyarea(bound_i(:,2),bound_i(:,1));
    end
    [~,bi_max] = max(area_b_i);
    boundary = boundary_points{bi_max};
    
    xrub = boundary(:,2);
    yrub = boundary(:,1);

    [a, b, phi, X0_in, Y0_in, X0, Y0] = fit_ellipse(xrub, yrub);

    major_axis = max(a,b);
    minor_axis = min(a,b);

    if b == major_axis
        phi = phi+pi/2;
    end 

    ellipse_fit.phi = phi;
    ellipse_fit.X_center = X0_in;
    ellipse_fit.Y_center = Y0_in;
    ellipse_fit.X0 = X0;
    ellipse_fit.Y0 = Y0;
    ellipse_fit.major_axis = major_axis*pixelsize;
    ellipse_fit.minor_axis = minor_axis*pixelsize;

    cell_boundaries.ellipse_fit=ellipse_fit;
    R = [ cos(phi) sin(phi); -sin(phi) cos(phi) ];
    for i = 1:length(boundary_points)
    xrub_0 = boundary_points{i}(:,2)-X0_in;
    yrub_0 = boundary_points{i}(:,1)-Y0_in;
    rotated_bounds{i} = (R'*[xrub_0'; yrub_0'])';
    end
    cell_boundaries.rotated_boundary_points = rotated_bounds;
    
    
    %% Rotate displacements and tractions
    im_size = size(Images{3});
    displacements_rr = rotate_and_center(phi,X0_in, Y0_in, im_size, uu);
    displacements_rr{3} = (displacements_rr{1}.^2 + displacements_rr{2}.^2).^0.5;
    tractions_rr = rotate_and_center(phi,X0_in,Y0_in, im_size, t);
    tractions_rr{3} = (tractions_rr{1}.^2 + tractions_rr{2}.^2).^0.5;

    cell_displacements.rotated_displacements = displacements_rr;
    cell_tractions.rotated_tractions = tractions_rr;

    %% Save data
    cell_data.cell_info = cell_info;
    cell_data.cell_boundaries = cell_boundaries;
    cell_data.cell_displacements = cell_displacements;
    cell_data.cell_tractions = cell_tractions;
    
    if nargin == 0
    all_cell_data{ind} = cell_data;
    save(['data out\' save_file_name],'all_cell_data','-v7.3')
    end
end
    
    save(['data out\' save_file_name '_rerun'],'all_cell_data','-v7.3')

end